'use strict'

const Resource = require('./resource')

/**
 * @namespace
 */
class Data extends Resource {
  /**
   * Retrieve a series of measurement from a resource
   *
   * Alias of **getMessage()**
   *
   * @param  {string} resource Name of the resources to retrieve measurements from
   * @param  {Object} params Object containing parameters for the query
   * @param  {number} [params.limit] Limit the amount of datapoints
   * @param  {number} [params.until] Timestamp in milliseconds
   * @param  {number} [params.from] Timestamp in milliseconds
   * @param  {string} [params.window] ISO-8601 duration See {@link https://en.wikipedia.org/wiki/ISO_8601#Durations}
   * @return {Promise<Array>}
   * @example await waylay.data.getSeries('testresource',{limit: 10, window: 'PT1H'})
   * @example // Response on resolve
   * [{
   *   "temperature": 32.22983748538228,
   *  "timestamp": 1617093236578
   * },{...},{...},{...},{...},{...},{...},{...},{...},{...}]
   */
  getSeries (resource, params) {
    return this._request({
      path: `/resources/${resource}/series`,
      params
    })
  }

  /**
   * Post a series of measurement to one or multiple resources.
   * The resource should be defined in the message object.
   * See {@link https://docs.waylay.io/#/api/broker/?id=posting-array-of-data}
   *
   * @function postSeries
   * @memberof Data.prototype
   * @param   {Object|Array} message The measurements to send to the data broker
   * @param   {Object} params Additional querystring parameters
   * @returns {Promise<Object>}
   * @example await waylay.data.postSeries([
   *{
   *         "resource": "testresource",
   *         "test": 1,
   *         "timestamp": 1617088527380
   *     },
   *{
   *         "resource": "testresource",
   *         "test": 2,
   *         "timestamp": 1617088527381
   *     }
   *])
   * @example // Response on resolve
   * {
   *    "message": "Batch uploaded 2 messages for resource testresource",
   *    "content": {}
   * }
   */

  /**
   * Post a series of measurement to a resource
   *
   * Alias of **postMessages()**
   *
   * See {@link https://docs.waylay.io/#/api/broker/?id=posting-data-towards-broker}
   *
   * @function postSeries
   * @memberof Data.prototype
   * @param   {string} resource Name of the resource to send measurements to
   * @param   {Object} message
   * @param   {Object} params Additional querystring parameters
   * @param   {boolean} params.store Store the data
   * @param   {boolean} params.forward Send the data to the broker
   * @returns {Promise<Object>} Object containg conformation of the action.
   * @example await waylay.data.postSeries('testresource',
   *  {
   *    'test': 1
   *  }
   *  , { store: true, forward: true })
   * @example // Response on resolve
   * {
   *  "message": "Published message async for testresource",
   *  "content": {
   *    "test": 1,
   *   "timestamp": 1617108869013
   *   }
   * }
   */
  postSeries (resource, message, params) {
    let bulk = typeof resource === 'object'
    if (bulk) {
      params = message
      message = resource
    }

    const opts = {
      path: bulk ? '/messages' : `/resources/${resource}`,
      method: 'POST',
      data: message,
      params: params
    }

    return this._request(opts)
  }

  /**
   * Remove a series of data from a resource
   * @param {string} resource
   * @param {string | array} metrics Comma-separated list of metrics to delete
   * @param {object} [params] Additional querystring parameters
   * @return {Promise<{ message: string }>} Promise object that resolves when the metrics have been deleted
   */
  deleteSeries (resource, metrics, params = {}) {
    return this._request({
      method: 'DELETE',
      path: `/resources/${resource}`,
      params: {
        ...params,
        metrics: Array.isArray(metrics) ? metrics.join(',') : metrics
      }
    })
  }

  /**
   * Query the time series storage for a particular resource.
   *
   * To disable aggregation, pass the value `none` to the options object.
   *
   * See {@link https://docs.waylay.io/#/api/broker/?id=time-series-data-retrieval}
   *
   * @example getMetricSeries('resource', 'metric', { aggregate: 'none' })
   * @example getMetricSeries('resource', 'metric', { aggregate: 'median', grouping: 'PT15M' })
   * @param  {string} resource ResourceId
   * @param  {string} metric The resource metric
   * @param  {Object} options Options to pass to the query
   * @param  {string} options.aggregate Possible options: mean, median, min, max, sum, count, count-numeric, count-non-numeric, first, last, std (standard deviation), percentile(n) (where 0 < n <= 1)
   * @param  {string} [options.grouping='auto'] ISO-8601 duration: PnDTnHnMn.nS
   * @param  {string | number} options.from ISO-8601 date times or timestamp in milliseconds since epoch
   * @param  {string | number} options.until ISO-8601 date times or timestamp in milliseconds since epoch
   * @param  {string} options.window ISO-8601 duration: PnDTnHnMn.nS Should be used in combination with the from key.
   * @return {Promise<Object>} Object containing the array of datapoints
   * @example await waylay.data.getMetricSeries('testresource','test', { aggregate: 'max',from: 1617088439000, window:'PT1H', grouping: 'PT1H' })
   * @example // Response on resolve
   * {
   *   "query": {
   *   "from": 1617088439000,
   *   "until": 1617110061759,
   *   "metric": "test",
   *   "aggregates": [
   *     "max"
   *   ],
   *   "grouping": "PT1H",
   *   "resources": [
   *     "testresource"
   *   ],
   *   "aggregate": "max"
   *  },
   * "series": [
   *  [1617088439000,2],[...],[...],[...],[...],[...],
   * ]
   *}
   */
  getMetricSeries (resource, metric, options) {
    const defaultOptions = {
      grouping: 'auto',
      aggregate: 'mean'
    }
    const params = Object.assign({}, defaultOptions, options)

    // "none" is an alias for "no aggregation", the API requires the 'aggregate'
    // value to be omitted for no aggregation to occur. We also omit the grouping
    // because it does not make sense to group non-aggregated data and the API
    // ignores it anyway.
    if (params.aggregate === 'none') {
      Object.assign(params, { aggregate: undefined, grouping: undefined })
    }

    return this._request({
      path: `/resources/${resource}/series/${metric}`,
      params
    })
  }

  /**
   * Query the time series storage for the latest n datapoints for a particular metric from a resource
   *
   * See {@link https://docs.waylay.io/#/api/broker/#post-timeseries-query}
   *
   * @param  {string} resource ResourceId
   * @param  {string} metric The resource metric
   * @param  {Object} [options] Extra options to pass to the query
   * @param  {number} [options.limit=2000] limit the amount of datapoints
   * @return {Promise<Object>} Object containing the array of datapoints
   * @example await waylay.data.getLastDatapointsForMetric('testresource','test', { limit: 10})
   * {
   *   "query": {
   *   "from": null,
   *   "until": 1617172322107,
   *   "metric": "test",
   *   "aggregates": null,
   *   "grouping": "auto",
   *   "resources": [
   *     "testresource"
   *   ],
   *   "limit": 10
   *  },
   *  "series": [[...],[...],[...],[...],[...],[...],[...],[...],[...],[...]]
   * }
   */
  getLastDatapointsForMetric (resource, metric, options) {
    const defaultOptions = {
      limit: 2000
    }
    const params = Object.assign({}, defaultOptions, options)

    return this._request({
      path: `/resources/${resource}/series/${metric}/last`,
      params
    })
  }

  /**
   * Query the time series storage for the latest n datapoints for a particular resource and metric and get them raw
   *
   * See {@link https://docs.waylay.io/#/api/broker/#getting-time-series-data}
   *
   * @param  {string} resource ResourceId
   * @param  {string} metric The resource metric
   * @param  {Object} [options] extra options to pass to the query
   * @param  {number} [options.limit=2000] limit the amount of datapoints
   * @return {Promise<Object>} Object containing the array of raw datapoints
   * @example await waylay.data.getDatapointsForMetricRaw('testresource','test', { limit: 10})
   * @example
   * {
   *  "query": {
   *    "from": 1616569296535,
   *    "until": 1617174096535,
   *    "metric": "test",
   *    "aggregates": null,
   *    "grouping": "auto",
   *    "resources": [
   *      "testresource"
   *    ],
   *    "limit": 10
   *  },
   *  "series": [
   *    [1617093236579, 1],[...],[...],[...],[...],[...],[...],[...],[...],[...],
   *  ]
   * }
   */
  getDatapointsForMetricRaw (resource, metric, options) {
    const defaultOptions = { limit: 2000 }
    const params = Object.assign({}, defaultOptions, options)

    return this._request({
      path: `/resources/${resource}/series/${metric}/raw`,
      params,
      headers: {
        Accept: 'application/hal+json'
      }
    })
  }

  /**
   * Perform a free-form time series query.
   *
   * This method allows aggregating a metric over one or more resources, using one or more aggregate operations.
   *
   * An example query object would be as follows:
   * <pre>
   *  {
   *     "from": "2019-03-05T05:30:00+01:00",
   *     "window": "PT2H",
   *     "resources": ["resource-a", "resource-b"],
   *     "aggregates": ["mean", "min", "max"],
   *     "metric": "temperature",
   *     "grouping": "PT1M"
   *  }
   * </pre>
   *
   * The response includes a 'series' field which contains an array of measurement arrays. Each of the nested
   * measurement arrays contains a timestamp value at index 0, and then one value per aggregate in the order that the
   * aggregates were supplied in the request. In the example request above, this results in values containing
   * <pre>[timestamp, meanValue, minValue, maxValue]</pre>.
   *
   * An example of output from the above query would be as follows:
   * <pre>
   *   {
   *     "query": {...},
   *     "series": [
   *        [1551760200000, 5.1, 1, 10],
   *        [1551760260000, 6.2, 0, 11],
   *        [1551760320000, 4.8, 2, 8],
   *        ...
   *     ]
   *   }
   * </pre>
   *
   * See {@link https://docs.waylay.io/#/api/broker/?id=time-series-data-retrieval} for more information on the
   * query definition.
   *
   * @param {Object} query as specified in the API docs for a POST time series query
   * @param {string | number} query.frorm ISO-8601 date times or timestamp in milliseconds since epoch
   * @param {string | number} query.until ISO-8601 date times or timestamp in milliseconds since epoch
   * @param {string} query.window ISO-8601 duration: PnDTnHnMn.nS Should be used in combination with the from key.
   * @param {Array} query.resources Array of resources you wish to query
   * @param {Array} query.aggregates Array of aggregates: mean, median, min, max, sum, count, count-numeric, count-non-numeric, first, last, std (standard deviation), percentile(n) (where 0 < n <= 1)
   * @param {string} query.metric The resource metric
   * @param {string} query.grouping Group data using ISO-8601 duration: PnDTnHnMn.nS
   * @returns {Promise<Object>} An object containing an array of measurement arrays
   * @example await waylay.data.queryTimeSeries({
   *      "window": "PT2H",
   *      "resources": ["testresource"],
   *      "aggregates": ["mean", "min", "max"],
   *      "metric": "test",
   *     "grouping": "PT1M"
   * })
   * @example // Response on resolve
   * {
   * "query": {
   *   "from": 1617167966555,
   *   "until": 1617175166555,
   *   "metric": "test",
   *   "aggregates": [
   *     "mean",
   *     "min",
   *     "max"
   *   ],
   *   "grouping": "PT1M",
   *   "resources": [
   *     "testresource"
   *   ]
   *  },
   *  "series": [Array(120)]
   * }
   */
  queryTimeSeries (query) {
    return this._request({
      path: `/series/query`,
      method: 'POST',
      data: query
    })
  }

  /**
   * You can retrieve messages for multiple resources from the message storage in one REST api call.
   *
   * The messages will always be grouped per resource. They will be sorted by timestamp in descending order.
   *
   * An example query object would be as follows:
   * <pre>
   *   {
   *      "resources": [ "abc123","def456"],
   *      "from":1572271520198,
   *      "until":1590745888140,
   *      "limit": 5
   *   }
   * </pre>
   *
   * See {@link https://docs.waylay.io/#/api/broker/#querying-messages-for-multiple-resources} for more information on the
   * query definition and response payload format.
   *
   * @param  {Object} query
   * @param  {string[]} query.resources Array of resources you want to fetch the messages from
   * @param  {number} query.from Timestamp in milliseconds since epoch
   * @param  {number} query.until Timestamp in milliseconds since epoch
   * @param  {number} [query.limit] Limit the amount of datapoints
   * @return {Promise}
   */
  queryMessages (query) {
    return this._request({
      path: `/messages/query`,
      method: 'POST',
      data: query
    })
  }

  /**
   * Retrieve the last measurement for a metric of a resource
   * @param  {string} resource ResourceId
   * @param  {string} metric The resource metric
   * @return {Promise<Object>}
   * @example await waylay.data.getLastMetric('testresource', 'test')
   * @example // Response on resolve
   * {
   *   "test": [
   *    1
   *   ],
   *  "timestamp": 1617108869013
   * }
   */
  getLastMetric (resource, metric) {
    return this._request({
      path: `/resources/${resource}/series/${metric}/latest`
    })
  }

  /**
   * Retrieve the last message sent to a resource
   * @param  {string} resource ResourceId
   * @return {Promise<Object>} The last message sent to resource
   * @example await waylay.data.getLatestDocument('testresource')
   * @example // Response on resolve
   * {
   *  "test": 1,
   *  "timestamp": 1617108869013
   * }
   */
  getLatestDocument (resource) {
    return this._request({
      path: `/resources/${resource}/current`
    })
  }

  /**
   * Retrieve up to the last 100 messages sent to a resource, allowing an optional filter object.
   *
   * see {@link https://docs.waylay.io/#/api/broker/#querying-messages-for-multiple-resources}
   *
   * @param  {string} resource The resourceId
   * @param  {object} [filter]
   * @param  {number} [filter.limit]
   * @return {Promise<Object[]>}
   * @example await waylay.data.getLatestMessages('testresource', { limit: 10 })
   * @example // Response on resolve
   * [
   *    {
   *     "test": 1,
   *    "timestamp": 1617108869013
   *   },
   *   {
   *     "test": 1,
   *     "timestamp": 1617093236579
   *   },{...},{...},{...},{...},{...},{...},{...},{...}
   * ]
   */
  getLatestMessages (resource, filter) {
    if (!filter) {
      return this._request({
        path: `/resources/${resource}/messages`
      })
    }

    // since the filtering isn't implemented on the GET request for a single resource,
    // we are using the queryMessages function and transforming the response to be the same
    // as the GET endpoint
    return this.queryMessages({
      ...filter,
      resources: [resource]
    })
      .then(response => {
        return response.results.length === 0
          ? []
          : response.results[0].messages
      })
  }

  /**
   * Remove all data and messages for a resource
   * @param  {string} resource The resourceId
   * @param {Object} [params] Extra parameters
   * @param {number} [params.from] Remove all data from timestamp
   * @param {number} [params.until] Remove all data until timestamp
   * @param {boolean} [params.onlytimeseries] Only remove timeseries data
   * @return {Promise<Object>}
   * @example await waylay.data.remove('testresource')
   * @example // Response on resolve
   * {
   *    "message": "Deleted messages, series and all metrics for testresource"
   * }
   */
  remove (resource, params) {
    return this._request({
      method: 'DELETE',
      path: `/resources/${resource}`,
      params
    })
  }
}

// aliases
Data.prototype.getMessages = Data.prototype.getSeries
Data.prototype.postMessage = Data.prototype.postSeries

module.exports = Data
