'use strict'

const BatchResource = require('./resource.batch')
const batch = require('./tasks.batch')
const qs = require('querystring')

/**
 * @namespace Tasks
 */
class Tasks extends BatchResource {
  constructor (options, client) {
    super(options, client)
    this.batch = batch.bind(this)()
  }

  /**
   * Create a new task
   *
   * See {@link https://docs.waylay.io/#/api/rules/#create-a-task}
   *
   * @param  {Task} task
   * @return {Promise}
   */
  create (task, params) {
    return this._request({
      path: '/api/tasks',
      method: 'POST',
      data: task,
      params
    })
  }

  /**
   * Update a task
   *
   * See {@link https://docs.waylay.io/#/api/rules/#update-a-task}
   *
   * @param  {Task} task
   * @return {Promise}
   */
  update (id, task) {
    return this._request({
      path: `/api/tasks/${id}`,
      method: 'PUT',
      data: task
    })
  }

  /**
   * List all tasks with optional filter
   *
   * See {@link https://docs.waylay.io/#/api/rules/#query-multiple-tasks}
   * @param  {string} [filter]
   * @param  {Object} params
   * @param  {Object} options
   * @return {Promise<Task[]>}
   */
  list (filter, params, options) {
    // function overloading: list(params, options)
    if (typeof filter === 'object') {
      options = params
      params = filter
      filter = undefined
    }

    if (typeof filter === 'string') params = { ...params, filter }

    params = Object.assign({
      limit: 10,
      offset: 0
    }, params)

    const { limit, offset, headers, ...restParams } = params

    return this._request({
      path: '/api/tasks',
      params: Object.assign({
        hits: limit,
        startIndex: offset
      }, restParams),
      headers,
      ...options
    })
  }

  count (options) {
    return this._request({
      method: 'head',
      wantsFullResponse: true,
      path: '/api/tasks',
      params: Object.assign({
        hits: 0,
        startIndex: 0
      }, options)
    }).then((response) => {
      const count = response.headers['x-count']
      return count ? Number(count) : undefined
    })
  }

  /**
   * Remove a task, will fail if task is still running
   * @param  {string} id
   * @return {Promise}
   */
  remove (id) {
    return this._request({
      path: `/api/tasks/${id}`,
      method: 'DELETE'
    })
  }

  /**
   * Remove multiple tasks, will fail if a task is still running
   * @param  {String[]} taskIdList
   * @return {Promise}
   */
  batchRemove (taskIdList = []) {
    return this._request({
      path: '/api/tasks',
      method: 'DELETE',
      params: {
        id: taskIdList
      }
    })
  }

  /**
   * Retrieve details of a task
   * @param  {string} id
   * @return {Promise}
   */
  get (id, params = {}, options) {
    return this._request({
      path: `/api/tasks/${id}`,
      params,
      ...options
    })
  }

  /**
   * Start a task that is not in a running state
   * @param  {string} id
   * @return {Promise}
   */
  start (id) {
    return this._request({
      path: `/api/tasks/${id}/command/start`,
      method: 'POST'
    })
  }

  /**
   * Stop a task that is in a running state
   * @param  {string} id
   * @return {Promise}
   */
  stop (id) {
    return this._request({
      path: `/api/tasks/${id}/command/stop`,
      method: 'POST'
    })
  }

  /**
   * Stop a task and remove it
   * @param  {string} id
   * @return {Promise}
   */
  stopAndRemove (id) {
    return this.stop(id).then(() => this.remove(id))
  }

  /**
   * Fetch logs for a task
   * @param {Object} options
   * @param {string} options.taskId
   * @param {string} options.logLevel
   * @param {string} options.messageContains
   * @param {int} options.from
   * @param {int} options.until
   * @param {string} options.pageToken
   * @return {Promise}
   */
  log ({ taskId, logLevel, messageContains, from, until, pageToken }) {
    return this._request({
      path: '/api/tasklogs',
      method: 'POST',
      data: {
        taskId,
        logLevel,
        messageContains,
        from,
        until,
        pageToken
      }
    })
  }

  /**
   * Push state to a node on a task
   * @param  {string} id Task id
   * @param  {string} node Task node
   * @param  {string} state Desired node state
   *
   * @return {Promise}
   */
  pushState (id, node, state) {
    const data = qs.stringify({ state })

    return this._request({
      path: `/api/tasks/${id}/nodes/${node}`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      data
    })
  }
}

module.exports = Tasks
