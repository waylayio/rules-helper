'use strict'

const url = require('url')

const Resource = require('./resource')
const { wantsLatestVersion } = require('./util')

/**
 * @namespace
 */
class Webscripts extends Resource {
  /**
   * Send data to a webscript
   *
   * @param  {string} namespace  Your unique webscripts namespace
   * @param  {string} name       The name of the webscript to execute
   * @param  {string|'latest'}   version The version on the webscript to execute
   * @param  {Object} body       Data to send to the webscript
   * @return {Promise}
   *
   * @example
   * waylay.webscripts.call('d15a29d7-4290-4bfa-aceb-d3f2e791737c', 'my-webscript', 'latest', { key: 'value' })
   *   .then(response => console.log(response))
   *   .catch(err => console.error(error))
   */
  call (namespace, name, version = 'latest', body) {
    const options = {
      path: `/api/v1/${namespace}/${name}`,
      method: 'POST',
      data: body
    }

    // Add webscript version header if version param !== latest
    if (!wantsLatestVersion(version)) {
      Object.assign(options, { headers: { 'X-Webscript-Version': version } })
    }

    return this._request(options)
  }

  /**
   * List your webscripts
   * @return {Promise<Webscript[]>} A list of webscripts
   */
  list () {
    return this._request(this._getEndpoint('/api/v1/webscripts'))
  }

  /**
   * Checks if webscript exists
   * @param  {string} name
   * @return {Promise<boolean>}
   */
  exists (name) {
    return this._request({
      ...this._getEndpoint(`/api/v1/webscripts/${name}`),
      method: 'HEAD'
    }).then(() => true).catch(() => false)
  }

  /**
   * Get details of one individual webscript
   * @param  {string} name
   * @param  {string} version
   * @return {Promise<Webscript>}
   */
  get (name, version = 'latest') {
    const options = this._getEndpoint(`/api/v1/webscripts/${name}`)

    // Add webscript version header if version param !== latest
    if (!wantsLatestVersion(version)) {
      options.headers = { 'X-Webscript-Version': version }
    }

    return this._request(options)
  }

  /**
   * Create a new webscript
   * @param  {Webscript} webscript
   * @return {Promise}
   */
  create (webscript) {
    return this._request({
      ...this._getEndpoint('/api/v1/webscripts'),
      method: 'POST',
      data: webscript
    })
  }

  /**
   * Remove a webscript
   * @param  {string} name
   * @return {Promise}
   */
  remove (name) {
    return this._request({
      ...this._getEndpoint(`/api/v1/webscripts/${name}`),
      method: 'DELETE'
    })
  }

  /**
   * Update a webscript - updates are **atomic**
   * @param  {string} name
   * @param  {Webscript} webscript
   * @return {Promise}
   */
  update (name, webscript) {
    return this._request({
      ...this._getEndpoint(`/api/v1/webscripts/${name}`),
      method: 'PUT',
      data: webscript
    })
  }

  /**
   * Retrieve logs from a webscript
   * @param  {string} name
   * @param  {string} [version='latest']
   * @return {Promise}
   */
  log (name, version = 'latest') {
    const options = this._getEndpoint(`/api/v1/webscripts/logs/${name}`)

    // Add webscript version header if version param !== latest
    if (!wantsLatestVersion(version)) {
      options.headers = { 'X-Webscript-Version': version }
    }

    return this._request(options)
  }

  // name should follow the pattern: 'operations/{operationId}'
  // TODO validate that input name starts with "operations/" prefix
  operation (name) {
    return this._request(this._getEndpoint(`/api/v1/webscripts/${name}`))
  }

  /**
   * Returns correct endpoint config:
   * url concatenated with path if registry url is configured otherwise just
   * default path
   * @param  {string} path
   * @return {Object}
   * @private
   */
  _getEndpoint (path) {
    const registryUrl = this._options.registry.baseUrl

    return registryUrl
      ? { url: url.resolve(registryUrl, path) }
      : { path }
  }
}

module.exports = Webscripts
