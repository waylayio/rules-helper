'use strict'

const Resource = require('./resource')
const debug = require('debug')('waylay:client')

var FormData
/* istanbul ignore if */
if (typeof window !== 'undefined' && /* istanbul ignore next */ window.FormData) {
  // in a browser
  FormData = window.FormData
} else {
  // on node-js
  FormData = require('form-data')
}

function trimObject (objectPath) {
  // remove leading slashes, deduplicate trailing slashes
  if (!objectPath) return ''
  return objectPath.replace(/^\/+/, '').replace(/\/+$/, '/')
}

function trimFolder (folderPath) {
  // assure and deduplicate trailing slashes and leading slashes
  if (!folderPath) return ''
  const folderPathTrimmed = folderPath.replace(/^\/+/, '').replace(/\/+$/, '')
  return folderPathTrimmed === '' ? '' : folderPathTrimmed + '/'
}

/**
* @description The waylay <em>Storage</em> service that interacts with file storage objects.
* @property {StorageBucket} [bucket] Manage the _buckets_ using the `/bucket/` API.
* @property {StorageObject} [object] Manage the _file objects_ using the `/bucket/{bucket}/{object_path}` API.
* @property {StorageFolder} [folder] Manage the _folder objects_ using the `/bucket/{bucket}/{folder_path}/` API.
* @property {StorageContent} [content] Access and modify the actual content of file objects, using signed urls.
* @property {StorageSubscription} [subscription] Manage the _subscriptions_ of the storage service using the `/subscription` API.
*/
class Storage {
  constructor (options, client) {
    this.bucket = new StorageBucket(options, client)
    this.object = new StorageObject(options, client)
    this.folder = new StorageFolder(options, client)
    this.content = new StorageContent(options, client)
    this.subscription = new StorageSubscription(options, client)
  }
}

/**
 * @description Storage API methods on a _bucket_.
 *
 * A _bucket_ is a top-level container for file objects having its own authorization policy.
 * On default deployments, buckets named `assets`, `public`, `etl-import` and `etl-export` are present.
 */
class StorageBucket extends Resource {
  /**
   * List all buckets for which the user is authorized.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<PagedListResponse | { buckets: StorageBucketEntity[] }>} A paged list response with a `buckets` listing.
   */
  list (options = {}) {
    return this._request({ path: '/bucket', params: options })
  }

  /**
   * Get the representation for a named bucket.
   * @param {string} bucket The name of the bucket that contains the objects. One of
   * `assets`, `public`, `etl-import`, `etl-export`.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<StorageBucketEntity | HALResponse>} A response object representing the bucket.
   */
  get (bucket, options = {}) {
    return this._request({ path: `/bucket/${bucket}`, params: options })
  }
}

/**
 * @description Storage API methods on a _file object_.
 *
 * A _file object_ represents a single storage location with a _bucket_, comparable to a file.
 */
class StorageObject extends Resource {
  /**
   * List objects in a bucket with a given path prefix.
   * @param {string} bucket The name of the bucket that contains the objects
   * @param {string} path The path prefix for the objects. The empty string (default) selects all paths.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.recursive When `false` (default), includes folders that have the given path prefix,
   *   but does not recurse into them. When `true`, recursively lists all objects with this prefix, ignoring folders.
   * @param {boolean} options.all When `false` (default) excludes _hidden_ objects whose basename start with `.`.
   *   When `true` includes _hidden_ objects and render advanced metadata properties for each object.
   * @param {number} options.max_keys [Paging] Page size: maximum number of objects returned in a list. When not specified, a server
   * default is applied (normally 200). The server also sets a limit to what a user can specify (normally 1000).
   * @param {string} options.start_after [Paging] Path prefix from after which the listing should start.
   * @returns {Promise<PagedListResponse | { objects: StorageObjectEntity[] }>} Has a `objects` property containing one page of list results.
   */
  list (bucket, path = '', options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: options
    })
  }

  /**
   * Get a representation of the file object at a specific path.
   * @param {string} bucket The name of the bucket that contains the objects
   * @param {string} path The file object for which metadata should be retrieved.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.all When `true`, render advanced metadata properties.
   * @returns {Promise<StorageObjectEntity | HALResponse>} The file object metadata.
   */
  get (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: Object.assign({}, options, { stat: true })
    })
  }

  /**
   * Create a signed GET url to fetch the file content at a specific path.
   *
   * The returned url contains all authentication, and expires after (by default)
   * 300 seconds. The total expiry period cannot exceed 7 days.
   * @param {string} bucket The name of the bucket that contains the objects
   * @param {string} path The path of the file object from which content should be retrieved.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.get_as_attachment If true, the file will be served with a `content-disposition` header.
   *  Browsers will treat this as an attachment that is meant to be saved to file.
   * @param {number} options.expiry_days Number of days to add to the expiry interval for this signed url.
   * @param {number} options.expiry_hours Number of hours to add to the expiry interval for this signed url.
   * @param {number} options.expiry_seconds Number of seconds to add to the expiry interval for this signed url.
   * @returns {Promise<HALResponse>} a HAL response containing a `get_object` fetch url.
   * @example
   * const signResp = await waylay.storage.object.signGet('assets', 'abc.json')
   * const resp = await fetch(signResp._links.get_object.href)
   * const myAbcData = resp.json()
   */
  signGet (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: Object.assign({}, options, { sign: 'GET' })
    })
  }

  /**
   * Create a signed PUT url to upload a file at a specific path.
   * The returned url contains all authentication, and expires after (by default)
   * 300 seconds.
   * @param {string} bucket The name of the bucket that contains the objects
   * @param {string} path The path at which the file object should be updated.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {number} options.expiry_days Number of days to add to the expiry interval for this signed url.
   * @param {number} options.expiry_hours Number of hours to add to the expiry interval for this signed url.
   * @param {number} options.expiry_seconds Number of seconds to add to the expiry interval for this signed url.
   * @param {string} options.content_type Policy requirement on the content type of uploads.
   * @param {boolean} options.all When `false` (default), do not allow the upload to hidden paths.
   * @returns {Promise<HALResponse>} a HAL response containing a `put_object` upload url.
   */
  signPut (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: Object.assign({}, options, { sign: 'PUT' })
    })
  }

  /**
   * Create a signed POST url and form parameters to upload a file at or below a specific path.
   * The returned url and parameters contain all authentication, and expire after (by default)
   * 300 seconds.
   * @param {string} bucket The name of the bucket that contains the objects.
   * @param {string} path The path at which the file object should be POST-ed.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {number} options.expiry_days Number of days to add to the expiry interval for this signed url.
   * @param {number} options.expiry_hours Number of hours to add to the expiry interval for this signed url.
   * @param {number} options.expiry_seconds Number of seconds to add to the expiry interval for this signed url. Default `300` (5 minutes).
   * @param {string} options.content_type Policy requirement on the content type of uploads.
   * @param {number} options.content_length_min Policy requirement on the minimum size of uploads.
   * @param {number} options.content_length_max Policy requirement on the maximum size of uploads.
   * @param {boolean} options.all When `false` (default), do not allow the upload to hidden paths.
   * @returns {Promise<HALResponse>} a HAL response containing a `post_object` link containing the POST
   * url and form parameters in `post_object.form_data`.
   *
   * @example
   * const signResp = await waylay.storage.object.signPost('assets', 'abc.txt')
   * const postUrl = signResp._links.post_object.href
   * const formData = signResp._links.post_object.form_data
   * formData['content-type'] = 'text/plain'
   * const postForm = new FormData(formData)
   *
   * // file is input of a <input type="file"> form
   * postForm.append('file', file)
   * const postResp = await fetch(postUrl, {
   *    method: 'POST',
   *    body: postForm
   * })
   * window.alert(postResp.ok ? 'File upload done', 'File upload failed')
   */
  signPost (bucket, path = '', options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: Object.assign({}, options, { sign: 'POST' })
    })
  }

  /**
   * Remove the file object at a specific path.
   * @param {string} bucket The name of the bucket that contains the objects
   * @param {string} path The full object path.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<HALResponse>} a HAL response with a `removed` link
   */
  remove (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: options,
      method: 'DELETE'
    })
  }

  /**
   * Remove all file objects whose path starts with a given prefix.
   * This method only deletes one page of objects (normally a default of 200 objects),
   * and will respond with a `next` link to delete a next page of objects.
   * @param {string} bucket name of the bucket that contains the folder
   * @param {string} path prefix path of objects to be removed
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.all When `false` (default), the presence of _hidden_ objects will fail the request.
   * @param {number} options.max_keys [Paging] Page size: maximum number of objects deleted in one request.
   * When not specified, a server default is applied (normally 200). The server also sets a limit to what a user can specify (normally 1000).
   * @param {string} options.start_after [Paging] Path prefix from after which the deletion should start.
   * @returns {Promise<PagedRemoveResponse>} A HAL response containing a `removed` link to the removed objects.
   * A `next` link might contain a reference to a next page of deletions.
   */
  removeAll (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimObject(path)}`,
      params: Object.assign({}, options, { recursive: true }),
      method: 'DELETE'
    })
  }
}

/**
 * @description Storage API methods on a _folder object_.
 *
 * A _folder object_ is a shared path for storage objects, comparable to a folder on a file system.
 * Note that _folder_ in an object store is only a virtual concept: a folder corresponds with
 * a prefix of stored objects ending in a '`/`'.
 * Waylay Storage creates an empty folder by registering a hidden empty object named `.folder`.
 */
class StorageFolder extends Resource {
  /**
   * List the content of a folder.
   * @param {string} bucket Name of the bucket that contains the folder
   * @param {string} path Name of the folder path. Normalized to end in a single `/`.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.recursive When `false` (default), includes subfolders of this folder,
   *  but does not recurse into them. When `true`, recursively lists all objects in this folder, ignoring folders.
   * @param {boolean} options.all When `false` (default) excludes _hidden_ objects whose basename start with `.`.
   *   When `true` includes _hidden_ objects and render advanced metadata properties for each object.
   * @param {number} options.max_keys [Paging] Page size: maximum number of objects returned in a list. When not specified, a server
   * default is applied (normally 200). The server also sets a limit to what a user can specify (normally 1000).
   * @param {string} options.start_after [Paging] Path prefix from after which the listing should start.
   * @returns {Promise<PagedListResponse | { objects: StorageObjectEntity[] }>} A response object having a `objects` property, containing one page
   * of listing results.
   */
  list (bucket, path = '', options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimFolder(path)}`,
      params: options
    })
  }

  /**
   * Get the metadata representation of a folder.
   * @param {string} bucket Name of the bucket that contains the folder.
   * @param {string} path Name of the folder path.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.all When `true`, render advanced metadata properties.
   * @returns {Promise<StorageObjectEntity | HALResponse>}
   */
  get (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimFolder(path)}`,
      params: Object.assign({}, options, { stat: true })
    })
  }

  /**
    * Create a signed POST url and form parameters to upload a file at or below a specific folder.
    * The returned url and parameters contain all authentication, and expire after (by default)
    * 300 seconds.
    * When using the form parameters to POST, the `key` property must be set to the intended object path.
    * On upload, the `key` parameter will be verified to have the `path` parameter of this method as a prefix.
    * @param {string} bucket The name of the bucket that contains the objects.
    * @param {string} path The folder beneath which the file object should be POST-ed.
    * @param {Object} options Optional arguments, url parameters in REST API.
    * @param {number} options.expiry_days Number of days to add to the expiry interval for this signed url.
    * @param {number} options.expiry_hours Number of hours to add to the expiry interval for this signed url.
    * @param {number} options.expiry_seconds Number of seconds to add to the expiry interval for this signed url.
    * @param {string} options.content_type Policy requirement on the content type of uploads.
    * @param {number} options.content_length_min Policy requirement on the minimum size of uploads.
    * @param {number} options.content_length_max Policy requirement on the maximum size of uploads.
    * @param {boolean} options.all When `false` (default), do not allow the upload to hidden paths.
    * @returns {Promise<HALResponse>} A HAL response containing a `post_object` link containing the POST
    * url and form parameters in `post_object.form_data`.
    *
    * @example
    * const signResp = await waylay.storage.object.signPost('assets', 'myfolder/')
    * const postUrl = signResp._links.post_object.href
    * const formData = signResp._links.post_object.form_data
    * // you can still update the `key` and `content-type`, but they will
    * // be checked against the sign policy.
    * formData.key = 'myfolder/abc.json'
    * formData['content-type'] =  'application/json'
    * const postForm = new FormData(formData)
    * // fileData is e.g. from a <input type="file"> form
    * postForm.append('file', fileData )
    * const postResp = await fetch(postUrl, {
    *    method: 'POST',
    *    body: postForm
    * })
    * window.alert(postResp.ok ? 'File upload done', 'File upload failed')
    */
  signPost (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimFolder(path)}`,
      params: Object.assign({}, options, { sign: 'POST' })
    })
  }

  /**
   * Create a folder at the given path location.
   * @param {string} bucket Name of the bucket that contains the folder
   * @param {string} path Name of the new folder path
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.all When `false` (default), do not allow the creation of hidden paths.
   * @returns {Promise<StorageObjectEntity | HALResponse>} A HAL response containing a link to the created object.
   */
  create (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimFolder(path)}`,
      params: options,
      method: 'PUT'
    })
  }

  /**
   * Remove a folder at the given location. The folder must be empty to succeed.
   * @param {string} bucket Name of the bucket that contains the folder
   * @param {string} path Name of the removed folder path
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<HALResponse>} A HAL response containing a `removed` link to the removed object.
   */
  remove (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimFolder(path)}`,
      params: options,
      method: 'DELETE'
    })
  }

  /**
   * Remove a folder and all its content at the given location.
   * This method only deletes one page of objects (normally a default of 200 objects),
   * and will respond with a `next` link to delete a next page of objects.
   * @param {string} bucket Name of the bucket that contains the folder
   * @param {string} path Name of the removed folder path
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {boolean} options.all When `false` (default), the presence of _hidden_ objects will fail the request.
   * @param {number} options.max_keys [Paging] Page size: maximum number of objects deleted in one request.
   * When not specified, a server default is applied (normally 200). The server also sets a limit to what a user can specify (normally 1000).
   * @param {string} options.start_after [Paging] Path prefix from after which the deletion should start.
   * @returns {Promise<PagedRemoveResponse>} A HAL response containing a `removed` link to the removed objects.
   * A `next` link might contain a reference to a next page of deletions.
   */
  removeAll (bucket, path, options = {}) {
    return this._request({
      path: `/bucket/${bucket}/${trimFolder(path)}`,
      params: Object.assign({}, options, { recursive: true }),
      method: 'DELETE'
    })
  }
}

/**
 * @description Storage API methods on _subscriptions.
 *
 * A _notification subscription_ is a rule that ties changes on file objects (upload, delete) to
 * invocations of a Waylay webscript.
 *
 * Once a _subscription_ is created, any upload or delete to an object that fits the `subscription.filters`,
 * will trigger the invocation of a _webscript_, as specified in `subscription.channel.name`.
 */
class StorageSubscription extends Resource {
  /**
   * List the active subscriptions on this bucket.
   * The listing contains one page of results, and contains a `next` HAL link when additional
   * pages are present.
   * @param {string} bucket Name of the bucket that contains the subscription
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {string} options.prefix [Search filter] Only list subscriptions that are affected by any object with this prefix.
   * @param {string} options.suffix [Search filter] Only list subscriptions that are affected by any object with this suffix.
   * @param {string} options.event_type [Search filter] Only list subscriptions that are affected by changes of this type. One of `put`, `delete`.
   * @param {string} options.channel_type [Search filter] Only list subscriptions that target a channel of this type. One of `webscript`, `system`, `webhook`.
   * @param {string} options.channel_id [Search filter] Only list subscriptions that target a channel having an id containing this string. For `webscript` channels, this is the script name.
   * @param {number} options.max_keys [Paging] Page size: maximum number of subscriptions listed in one request.
   * When not specified, a server default is applied (normally 200). The server also sets a limit to what a user can specify (normally 1000).
   * @param {string} options.start_after [Paging] Id prefix from after which the listing should start.
   * @returns {Promise<PagedListResponse | { subscriptions: StorageSubscriptionEntity[] }>} one page of subscriptions.
   */
  list (bucket, options = {}) {
    return this._request({
      path: `/subscription/${bucket}`,
      params: options
    })
  }

  /**
   * Get the subscription with the given id.
   * @param {string} bucket Name of the bucket that contains the subscription
   * @param {string} id Id of the subscription
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<StorageSubscriptionEntity | HALResponse>} Representation of the subscription
   */
  get (bucket, id, options = {}) {
    return this._request({
      path: `/subscription/${bucket}/${id}`,
      params: options
    })
  }

  /**
   * Create a new subscription.
   * @param {string} bucket Name of the bucket that contains the subscription
   * @param {StorageSubscriptionEntity} subscription Representation of a new subscription. See API documentation. When no
   * `id` property is specified, a generated id will be assigned. When a specified `id` conflics
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<StorageSubscriptionEntity | HALResponse>} A HAL response containing the created subscription.
   * This will fail if a _subscription_ with the specified `subscription.id` already exists.
   */
  create (bucket, subscription, options = {}) {
    return this._request({
      path: `/subscription/${bucket}`,
      params: options,
      data: subscription,
      method: 'POST'
    })
  }

  /**
   * Replace the definition of a subscription.
   * @param {string} bucket Name of the bucket that contains the subscription
   * @param {id} id Id of the subscription to be replaced. If no such subscription exists,
   * a new subscription will be created.
   * @param {StorageSubscriptionEntity} subscription Representation of a new subscription. See API documentation.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<StorageSubscriptionEntity | HALResponse>} A HAL response containing the created or updated subscription.
   */
  replace (bucket, id, subscription, options = {}) {
    return this._request({
      path: `/subscription/${bucket}/${id}`,
      params: options,
      data: subscription,
      method: 'PUT'
    })
  }

  /**
   * Remove a subscription.
   * @param {string} bucket Name of the bucket that contains the subscription
   * @param {id} id Id of the subscription to be removed.
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @returns {Promise<HALResponse>} A HAL response containing a link to the removed subscription.
   */
  remove (bucket, id, options = {}) {
    return this._request({
      path: `/subscription/${bucket}/${id}`,
      params: options,
      method: 'DELETE'
    })
  }

  /**
   * Remove (one page of) subscriptions that satisfy a query.
   * @param {string} bucket Name of the bucket that contains the subscriptions
   * @param {Object} options Optional arguments, url parameters in REST API.
   * @param {string} options.prefix [Search filter] Only delete subscriptions that are affected by any object with this prefix.
   * @param {string} options.suffix [Search filter] Only delete subscriptions that are affected by any object with this suffix.
   * @param {string} options.event_type [Search filter] Only delete subscriptions that are affected by changes of this type. One of `put`, `delete`.
   * @param {string} options.channel_type [Search filter] Only delete subscriptions that target a channel of this type. One of `webscript`, `system`, `webhook`.
   * @param {string} options.channel_id [Search filter] Only delete subscriptions that target a channel having an id containing this string. For `webscript` channels, this is the script name.
   * @param {number} options.max_keys [Paging] Page size: maximum number of subscriptions deleted in one request.
   * When not specified, a server default is applied (normally 200). The server also sets a limit to what a user can specify (normally 1000).
   * @param {string} options.start_after [Paging] Id prefix from after which the deletion should start.
   * @returns {Promise<PagedRemoveResponse>} A HAL response containing a link to the removed subscriptions.
   * If a `next` HAL link is present, more subscriptions are left to be deleted
   */
  removeAll (bucket, options = {}) {
    return this._request({
      path: `/subscription/${bucket}`,
      params: options,
      method: 'DELETE'
    })
  }
}

/**
 * Upload and download the actual content of the file objects.
 *
 * Uses the _signed urls_ produced by {@link #storageobjectsignpost object.signPost} and
 * {@link #storagefoldersignpost folder.signPost}.
 *
 * Data content for uploads can be [provided as](https://github.com/axios/axios#axiosposturl-data-config)
 * - `string`, plain object, `ArrayBuffer`
 * - (in browser) `FormData`, `File`, `Blob`
 * - (on node scripts) `Stream`, `Buffer`
 *
 */
class StorageContent {
  constructor (options, client) {
    this._options = options
    this._client = client
  }

  _contentRequest (requestOptions) {
    /* istanbul ignore next */
    if (typeof window === 'undefined' && typeof process === 'object') {
      requestOptions.headers = Object.assign({}, requestOptions.headers, {
        'User-Agent': `waylay-js`
      })
    }

    debug('Making request: \n%O', requestOptions)

    return this._client.httpClient(requestOptions).then(
      resp => this.wantsFullResponse ? resp : resp.data
    )
  }
  _getResponseData (response) {
    return this.wantsFullResponse ? response.data : response
  }

  get wantsFullResponse () {
    return this._client.wantsFullResponse || this._options.wantsFullResponse
  }

  /**
   * Get the content of the file object at a given location.
   * This combines a {@link #storageobjectsignput storage.object.signGet} with
   * a {@link #storagecontentgetsigned storage.content.getSigned}.
   * @param {string} bucket Name of the bucket
   * @param {string} path object path at which a file should be uploaded
   * @param {Object} options Optional parameters used when signing the get url.
   * @returns {Promise<any>} the response data
   */
  get (bucket, path, options = {}) {
    return this._client.storage.object.signGet(bucket, path, options).then(
      resp => this.getSigned(this._getResponseData(resp)._links.get_object)
    )
  }

  /**
   * Get content of a file object, based
   * on a response of a  {@link #storageobjectsignGet storage.object.signGet} request.
   * @param {HALLink} signGetResponse `get_object` link from a {@link #storageobjectsignget storage.object.signGet}.
   * @returns {Promise<any>} the response of the put request.
   */
  getSigned (signGetResponse) {
    return this._contentRequest({
      url: signGetResponse.href,
      method: 'GET'
    })
  }

  /**
   * Upload local data to a file object at a given location.
   * This combines a {@link #storageobjectsignput storage.object.signPut} with
   * a {@link #storagecontentputsigned storage.content.putSigned}.
   * @param {string} bucket Name of the bucket
   * @param {string} path object path at which a file should be uploaded
   * @param {string|Object|ArrayBuffer|File|Blob|Stream|Buffer} data the content to be uploaded.
   * @param {Object} options Optional parameters used when signing the put url.
   * @param {string} options.content_type content type with which the file should be stored.
   * @returns {Promise<any>} the response message of the file upload
   */
  put (bucket, path, data, options = {}) {
    const { content_type: contentType } = options
    return this._client.storage.object.signPut(bucket, path, options).then(
      resp => this.putSigned(this._getResponseData(resp)._links.put_object, data, { content_type: contentType })
    )
  }

  /**
   * Put the content of local data to a file object at a given location, based
   * on a response of a  {@link #storageobjectsignput storage.object.signPut} request.
   * @param {HALLink} signPutResponse `put_object` link from a {@link #storageobjectsignput storage.object.signPut}.
   * @param {string|Object|ArrayBuffer|File|Blob|Stream|Buffer} data the content to be uploaded.
   * @param {Object} options Optional parameters
   * @param {string} options.content_type content type with which the file should be stored.
   * @returns {Promise<any>} the response of the put request.
   */
  putSigned (signPutResponse, data, { content_type: contentType } = {}) {
    const putOptions = {
      url: signPutResponse.href,
      data: data,
      method: 'PUT'
    }
    if (contentType) {
      putOptions.headers = { 'content-type': contentType }
    }
    return this._contentRequest(putOptions)
  }

  /**
   * Upload local content to a file object at a given location.
   * This combines a {@link #storageobjectsignpost storage.object.signPost} with
   * a {@link #storagecontentpostsigned storage.content.postSigned}.
   * @param {string} bucket Name of the bucket
   * @param {string} path object path at which a file should be uploaded
   * @param {string|Object|ArrayBuffer|File|Blob|Stream|Buffer} data the content to be uploaded.
   * @param {Object} options Optional parameters
   * @param {string} options.content_type content type with which the file should be stored.
   * @returns {Promise<any>} the response message of the file upload
   */
  post (bucket, path, data, options = {}) {
    const { content_type: contentType } = options
    return this._client.storage.object.signPost(bucket, path, options).then(
      resp => this.postSigned(this._getResponseData(resp)._links.post_object, data, { content_type: contentType })
    )
  }

  /**
   * Upload local content to a file object at a given location, based
   * on a response of a  {@link #storageobjectsignpost storage.object.signPost} request.
   * @param {HALLink} signPostResponse `post_object` link from of a {@link #storageobjectsignpost storage.object.signPost}.
   * @param {string|Object|ArrayBuffer|File|Blob|Stream|Buffer} data the content to be uploaded.
   * @param {Object} options Optional parameters
   * @param {string} options.content_type content type with which the file should be stored.
   * @param {string} options.path exact path at which to upload the file. This might be different from the file name,
   * but should contain the `path` from the original signPost request as a prefix.
   * @returns {Promise<any>} the response message of the file upload
   */
  postSigned (signPostResponse, data, { content_type: contentType, path } = {}) {
    let formParams = Object.assign({}, signPostResponse.form_data)
    if (contentType) formParams['content-type'] = contentType
    if (path) formParams['key'] = path
    let form = new FormData(formParams)
    // TODO this works for `File` uploads, but to check for other content ...
    form.append('file', data)
    return this._contentRequest({
      url: signPostResponse.href,
      data: form,
      method: 'POST'
    })
  }
}

module.exports = Storage

/**
 * Representation of a Subscription Channel, a target to send object change notifications to.
 * @typedef {Object} SubscriptionChannel
 * @param {string} type Type of the channel. One of `webscript`, `system`, `webhook`.
 *        Users can only create subscriptions for `webscript` channels.
 * @param {string} name Name of the channel. For `webscripts`, this corresponds to the webscript name.
 * @param {string} method Http method to use when invoking the (webscript) channel.
 *        One of `GET` `POST` `PUT`.
 *        When `POST` or `PUT` is used, the webscript will receive a body of
 *        type {@link #subscriptionnotification StorageNotification}.
 * @param {string} version (optional) The version of the webscript.
 * @param {string} description A user description of the invoked channel.
 * @param {Object} expiry Specification of the period in which forwarded messages should remain usable.
 *        This influences the expiry of signed urls and authentication tokens that are present in the forwarded message.
 *        The total expiry period can not be larger than 7 days.
 *        If not specified, an expiry of 300 seconds (5 minutes) holds.
 * @param {string} expiry.seconds Seconds to add to the expiry period.
 * @param {string} expiry.hours Hours to add to the expiry period.
 * @param {string} expiry.days Days to add to the expiry period.
 * @param {Object} payload Options to modify the content of the forwarded {@link #subscriptionnotification StorageNotification}.
 * @param {string[]} payload.signed_links Signed links that must be present in the message as HAL link.
 *        This enables the receiver of the message (the webscript) to retrieve or update
 *        the content of the object without additional authentication.
 * @param {any} payload.reference Fixed json value that will be included in the message.
 * @param {Object} authentication Specification of the authentication method used to call the (webscript) channel.
 *        If not specified, a default mechanism is used.
 * @param {string} authentication.method The authentication method.
 *        One of `DEFAULT`, `NONE`, `API_KEY`, `TOKEN`, `WAYLAY_APP`, `WAYLAY_TOKEN`, `WEBSCRIPT`.
 * @param {string} authentication.key The authentication key, only relevant for `API_KEY` and `WAYLAY_TOKEN` method.
 * @param {string} authentication.secret The authentication secret, relevant for `API_KEY`, `TOKEN`, `WAYLAY_TOKEN` and `WEBSCRIPT` methods.
 *        Note that this value gets encrypted to a read-only value with an enc: prefix when retrieved from the server.
 *        The value should be unencrypted in a subscription create or update request.
 */

/**
 * Filter condition on a object change notification.
 * @typedef {Object} SubscriptionFilter
 * @param {string} prefix If present, the path of the changed object must have this prefix.
 * @param {string} suffix If present, the path of the changed object must have this suffix.
 * @param {string[]} events The event types, either `put` (any creation or update) or `delete` (removal of the object) or both.
 *        When not specified , `['put']` is assumed.
 * @param {string} description A user description for this filter.
 * @param {string} queue Readonly id of the notification queue that is handling the subscription.
 *        When present, it is a proof that the subscription is correctly registered.
 *        Should be left empty when creating or updating a subscription.
 */

/**
 * Representation of a storage subcription
 * @typedef {Object} StorageSubscriptionEntity
 * @param {string} id The unique identifier for the subscription, optional when creating a subscriptions.
 * @param {string} title A display title for this subscription.
 * @param {string} description A description for this subscription.
 * @param {SubscriptionChannel} channel The specification of the target to which notifications must be forwarded.
 * @param {SubscriptionFilter[]} filters The event filters that specify what changes will trigger the notification.
 */

/**
 * Representation of a _Storage Store_, representing the actual
 * storage solution for which the _storage API_ controls access.
 * @typedef {Object} StorageStoreEntity
 * @param {string} type Store type, one of `minio_gs`, `minio`, `minio_s3`, `minio_azure`.
 * @param {string} name Store name.
 * @param {string} url Base content url of the storage solution (S3 Protocol)
 */

/**
 * Representation of a _Storage Bucket_.
 * @typedef {Object} StorageBucketEntity
 * @param {string} name Full, globally unique name of the storage bucket.
 * @param {string} alias Short name of the bucket, unique in tenant scope.
 * @param {StorageStoreEntity} store Backend store supporting this bucket.
 */

/**
 * Representation of a _Storage Object_.
 * @typedef {Object} StorageObjectEntity
 * @param {string} name The full name of the file object, including its path.
 * @param {StorageBucketEntity} bucket The bucket in which this object is stored.
 * @param {string} last_modified Last modification date (ISO-8601 timestamp)
 * @param {string} etag ETag caching header value used in content urls.
 * @param {number} size Size of the stored content.
 * @param {string} content_type Registered content type.
 * @param {boolean} is_dir True if the entity represents a (virtual) folder. Folders in an object store
 *        are only prefixes of stored object that end in a `'/'`.
 */

/**
 * Notification message as sent to a channel
 * @typedef {Object} StorageNotification
 * @param {string} event The type of the event, either  `put` or `delete`.
 * @param {StorageObjectEntity} object The storage object that changed, including HAL links.
 * @param {string} event_time The event time (ISO8601 string) of the object change.
 * @param {any} reference The json value as configured in `channel.payload.reference` of the subscription.
 * @param {string} tenant The id of the Waylay tenant that owns this object.
 * @param {string} store The name of the storage backend store that originated this change event.
 */

/**
 * HAL link object as returned by the server.
 * @typedef {Object} HALLink
 * @param {string} href URL for this link.
 * @param {string} method HTTP method to use for this link, if not `GET`.
 * @param {Object} form_data Default multipart form data for POST links.
 */

/**
 * Response object containing linked REST actions.
 *
 * The storage api uses the following link roles as keys in the `_links` object
 * - `self`: the url of the resource that is represented in the response.
 * - `list`, `remove`, `update`, `create` basic _CRUD_ actions on a _storage_ entity.
 * - `sign_get`, `sign_put`, `sign_post`: REST actions that create signed urls to the content of a _storage object_.
 * - `get_object`, `put_object`, `post_object`: The resulting signed url link to the object content.
 * - `get`, `put`, `post`: public links to the _content_ of storage objects (these do not require signing).
 * - `first`, `next`: paging links used in paged listing and deletion.
 * - `removed`: links to deleted entities.
 * - `store`, `bucket`, `subscriptions`: links to related (parent or child) entities.
 *
 * The _storage_ server includes links according to the authorization level of the authenticated user.
 * Link roles that are present can hence be used to present a user the authorized actions for a given resource.
 *
 * (Note: combined types are annotated with a _union_ type (`| HALResponse`), but should be read as an _intersection type_ (`& HALResponse`))
 * @typedef {Object} HALResponse
 * @param {Object.<string,HALLink|HALLink[]>} _links HAL links relevant to the context, indexed by link role.
 */

/**
 * HAL response for paged listings.
 *
 * List response objects have an property (`objects`, `buckets`, `subscriptions`) that
 * contains the listed entities.
 *
 * (Note: combined types are annotated with a _union_ type  (`| PagedListResponse`), but should be read as an _intersection type_ (`& PagedListResponse`))
 * @typedef {HALResponse} PagedListResponse
 * @param {Object.<string,HALLink|HALLink[]>} _links HAL links.
 * @param {HALLink} _links.self link to this page of the listing.
 * @param {HALLink} _links.next link to the next page for the listing, if applicable.
 * @param {HALLink} _links.first link to the first page for the listing, if applicable.
 */

/**
 * HAL response for paged deletion.
 * @typedef {HALResponse} PagedRemoveResponse
 * @param {Object.<string,HALLink|HALLink[]>} _links HAL links.
 * @param {HALLink} _links.self link to the exected deleta action.
 * @param {HALLink} _links.next link to the next page for to delete, if applicable.
 * @param {HALLink[]} _links.removed links to deleted entities.
 */
