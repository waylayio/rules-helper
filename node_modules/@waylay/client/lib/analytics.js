'use strict'

const Resource = require('./resource')

/**
 * @namespace Analytics
 * @description Analytics allows you to calculate anomalies and predict future values of timeseries
 */
class Analytics extends Resource {
  /**
   * Execute fit for a the stored Analytics Option Configuration.
   * See [fit REST api]{@link https://ts-analytics.waylay.io/apidocs/#/fit/post_fit__config_resource___config_name_}
   * for documentation on the request and response object.
   *
   * @param  {string} resource
   * @param  {string} tsaConfig the name of the tsa configuration
   * @param  {Object} options the option configuration overrides for the fit call (see REST API)
   * @param  {boolean} useConfig set explicitely to false to NOT use a stored ts-analaytics option config.
   * @param  {object} urlParams optional urlParams (such as api_version, debug, and overrides)
   * @return {Promise}
   */
  fit (resource, tsaConfig, options = undefined, useConfig = true, urlParams = undefined) {
    return this._usecase('fit', resource, tsaConfig, options, useConfig, urlParams)
  }

  /**
   * Calculate anomalies. See [anomaly REST api]{@link https://ts-analytics-staging.waylay.io/apidocs/#/anomaly/post_anomaly__config_resource___config_name_}
   * for documentation on the request and response object
   *
   * @param  {string} resource
   * @param  {string} tsaConfig the name of the tsa configuration
   * @param  {Object} options the option configuration overrides for the anomaly call (see REST API)
   * @param  {boolean} useConfig set explicitely to false to NOT use a stored ts-analaytics option config.
   * @param  {object} urlParams optional urlParams (such as api_version, debug, and overrides)
   * @return {Promise}
   */
  anomaly (resource, tsaConfig, options = undefined, useConfig = true, urlParams = undefined) {
    return this._usecase('anomaly', resource, tsaConfig, options, useConfig, urlParams)
  }

  /**
   * Predict future values. See [predict REST api]{@link https://ts-analytics-staging.waylay.io/apidocs/#/predict/post_predict__config_resource___config_name_}
   * for documentation on the request and response object
   *
   * @param  {string} resource
   * @param  {string} tsaConfig the name of the tsa configuration
   * @param  {Object} options the option configuration overrides for the predict call (see REST API)
   * @param  {boolean} useConfig set explicitely to false to NOT use a stored ts-analaytics option config.
   * @param  {object} urlParams optional urlParams (such as api_version, debug, and overrides)
   * @return {Promise} wraps the REST response
   */
  predict (resource, tsaConfig, options = undefined, useConfig = true, urlParams = undefined) {
    return this._usecase('predict', resource, tsaConfig, options, useConfig, urlParams)
  }

  /**
   * Execute validation of tsanalytics algorithm options. See [validate REST api]{@link https://ts-analytics-staging.waylay.io/apidocs/#/validate/post_validate__config_resource___config_name_}
   * for documentation on the request and response object
   *
   * @param  {string} resource
   * @param  {string} tsaConfig the name of the tsa configuration
   * @param  {Object} options the option configuration overrides for the predict call (see REST API)
   * @param  {boolean} useConfig set explicitely to false to NOT use a stored ts-analaytics option config.
   * @param  {object} urlParams optional urlParams (such as api_version, debug, and overrides)
   * @return {Promise} wraps the REST response
   */
  validate (resource, tsaConfig, options = undefined, useConfig = true, urlParams = undefined) {
    return this._usecase('validate', resource, tsaConfig, options, useConfig, urlParams)
  }

  /**
   * Call an analytics use case
   *
   * @param  {string} usecase one of ['fit','anomaly','predict','validate']
   * @param  {string} resource id of the resource that owns the data and/or configuration
   * @param  {string} tsaConfig the name of the tsa configuration
   * @param  {Object} options ts-analytics options that override the default (or stored) options
   * @param  {boolean} useConfig if true (default), use the ts-analytics option config stored in the metadata of the resource
   * @param  {object} urlParams optional urlParams (such as api_version, debug, and overrides)
   * @return {Promise}
   * @private
   */
  _usecase (usecase, resource, tsaConfig, options, useConfig = true, urlParams = undefined) {
    if (!resource || !tsaConfig) {
      return Promise.reject(new TypeError("options is incomplete, doesn't include resource and/or tsaConfig"))
    }
    var urlParamsEncoded = ''
    if (urlParams != null) {
      urlParamsEncoded = '?' + Object.keys(urlParams).map(key => `${key}=${urlParams[key]}`).join('&')
    }
    if (useConfig) {
      if (options) {
        return this._request({
          path: `/${usecase}/${resource}/${tsaConfig}${urlParamsEncoded}`,
          data: options,
          method: 'POST'
        })
      } else {
        return this._request({
          path: `/${usecase}/${resource}/${tsaConfig}${urlParamsEncoded}`,
          method: 'GET'
        })
      }
    } else {
      return this._request({
        path: `/${usecase}${urlParamsEncoded}`,
        data: generateData(resource, tsaConfig, options),
        method: 'POST'
      })
    }
  }

  /**
   * Get parameters of a specific ts-analaytics option config
   * @param  {string} resource id of the resource
   * @param  {string} configId name of the configuration
   * @return {Promise}
   */
  config (resource, configId) {
    if (!resource || !configId) {
      return Promise.reject(new TypeError("data is incomplete, doesn't include resource and/or tsaConfig"))
    }

    return this._request({
      path: `/config/${resource}/${configId}`
    })
  }

  /**
   * Replace the config definition of a specific ts-analaytics option config
   * This config will be completely overwritten
   * @param  {string} resource id of the resource
   * @param  {string} configId name of the configuration
   * @param  {Object} config the configuration definition
   * @return {Promise}
   */
  replaceConfig (resource, configId, config) {
    if (!resource || !configId || !config) {
      return Promise.reject(new TypeError("data is incomplete, doesn't include resource, configId and/or config"))
    }

    return this._request({
      path: `/config/${resource}/${configId}`,
      data: config,
      method: 'PUT'
    })
  }

  /**
   * Update the config definition of a specific ts-analaytics option config
   * This does not overwrite the complete existing config
   * @param  {string} resource id of the resource
   * @param  {string} configId name of the configuration
   * @param  {Object} config the configuration definition
   * @return {Promise}
   */
  updateConfig (resource, configId, config) {
    if (!resource || !configId || !config) {
      return Promise.reject(new TypeError("data is incomplete, doesn't include resource, configId and/or config"))
    }

    return this._request({
      path: `/config/${resource}/${configId}`,
      data: config,
      method: 'PATCH'
    })
  }

  /**
   * Create a config definition for a resource
   * @param  {string} resource id of the resource
   * @param  {Object} config the configuration definition
   * @return {Promise}
   */
  createConfig (resource, configId, config) {
    if (!resource || !configId || !config) {
      return Promise.reject(new TypeError("data is incomplete, doesn't include resource and/or config"))
    }

    return this._request({
      path: `/config/${resource}`,
      data: {
        name: configId,
        options: config
      },
      method: 'POST'
    })
  }

  /**
   * Remove a certain tsa configuration
   * @param  {string} resource
   * @param  {string} configId
   * @return {Promise}
   */
  removeConfig (resource, configId) {
    if (!resource || !configId) {
      return Promise.reject(new TypeError("data is incomplete, doesn't include resource and/or configId"))
    }

    return this._request({
      path: `/config/${resource}/${configId}`,
      method: 'DELETE'
    })
  }

  /**
   * Get all ts-analaytics option configs for a specific resource
   * @param  {string} resource
   * @return {Promise}
   */
  configs (resource) {
    return this._request({
      path: `/config/${resource}`
    })
  }

  /**
   * Get a certain query
   * @param  {string} queryName name of the query that should be returned
   * @return {Promise}
   */
  getQuery (queryName) {
    if (!queryName) {
      throw new Error("data is incomplete, doesn't include queryName")
    }

    return this._request({
      path: `/config/query/${queryName}`
    })
  }

  /**
   * Remove a certain query
   * @param  {string} queryName name of the query that should be removed
   * @return {Promise}
   */
  removeQuery (queryName) {
    if (!queryName) {
      throw new Error("data is incomplete, doesn't include queryName")
    }

    return this._request({
      path: `/config/query/${queryName}`,
      method: 'DELETE'
    })
  }

  /**
   * Create a new query
   * @param  {string} queryName name to which the query should be saved
   * @param  {object} query the query specification
   * @return {Promise}
   */
  createQuery (queryName, query) {
    if (!queryName || !query) {
      throw new Error("data is incomplete, doesn't include queryName or query")
    }

    return this._request({
      path: `/config/query/${queryName}`,
      data: { query },
      method: 'PUT'
    })
  }

  /**
   * Replace a query, this will completely overwrite the current existing query
   * @param  {string} queryName name of the query that should be updated
   * @param  {object} query the query specification updates
   * @return {Promise}
   */
  replaceQuery (queryName, query) {
    if (!queryName || !query) {
      throw new Error("data is incomplete, doesn't include queryName or query")
    }

    return this._request({
      path: `/config/query/${queryName}`,
      data: { query },
      method: 'PUT'
    })
  }

  /**
   * Get a subset of all queries using an optional filter string
   * @param {Object} [options] options for getting queries, this object can contain:
   * @param {string} [options.filter = ''] the filter string as specified in the query DSL, leave empty to get all queries
   * @param {number} [options.offset = 0] the number of queries to skip as offset
   * @param {number} [options.limit = 100] the number of queries per page
   */
  getQueries ({ filter = '', offset = 0, limit = 100 } = {}) {
    return this._request({
      path: `/config/query`,
      params: {
        q: filter,
        offset,
        limit
      }
    })
  }

  /**
   * Get the data as specified by a query
   * @param {string} queryName name of the query specification to use
   * @param {Object} [options = {}] config overwrites, can be used to specify `window`, `from` and `until` for example
   */
  getQueryData (queryName, options = {}) {
    if (!queryName) {
      throw new Error("data is incomplete, doesn't include queryName")
    }

    return this._request({
      path: `/data/query/${queryName}`,
      params: {
        'render.mode': 'RENDER_MODE_SERIES',
        ...options
      }
    })
  }
}

/**
* @private
*/
function generateData (resource, tsaConfig, options = {}) {
  // backwared compatibility: use tsaConfig as metric when needed
  return Object.assign({ resource, metric: tsaConfig }, options)
}

module.exports = Analytics
module.exports.generateData = generateData
